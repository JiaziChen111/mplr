function [IRF_in, collector] = task1(VAR_config)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % task1 - Section 3.1 - Summarizing the identified set in
    % set-identified SVARs
    %
    % Inputs
    % VAR_config - object generated by SVAR_config.m
    %
    % Outputs
    % IRF_in - included IRF's
    % collector - collects info about number of draws
    %    [included draws; rejected draws; total draws]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    % Unspool
    A = VAR_config.A;
    Sigma = VAR_config.Sigma;
    cholsig = VAR_config.cholsig;
    restrictionCell = VAR_config.restrictionMatrix;
    drawMatrix = VAR_config.drawMatrix;
    nhorizon = VAR_config.nhorizon;
    nlag = VAR_config.nlag;
    constant = VAR_config.constant;
    nobs = VAR_config.nobs;
    nvar = VAR_config.nvar;
    cholsig = VAR_config.cholsig;
    Y = VAR_config.Y;
    X = VAR_config.X;
    T = VAR_config.T;
 
    % Number of shocks
    nshocks = size(restrictionCell, 3);
 
    % Precompute IRF coefficients (without orth matrix)
    [IRF_coef, LR_coef] = IRF_coeff(A, cholsig, nlag, nhorizon, constant);
 
    % Stopping criterion
    flagIndiv = false(size(drawMatrix, 1), 1);
    flagStop = false;
 
    % Matrix to collect info
    collector = zeros(size(drawMatrix, 1), nvar);
 
    % Maxdraws for preallocation
    maxdraws = max(drawMatrix(:, 1));
 
    % Preallocate
    IRF_in = zeros(nvar, nvar, nhorizon, maxdraws);
 
    ad = 0; % accepted draws
    rd = 0; % rejected draws
    td = 0; % total draws
    ww = 1; % index for printing on screen
 
    % Generate W matrices (one for each shock) s.t. Wq <= 0 to check SR
    Wcell = cell(nshocks);
    for ii = 1:nshocks
        Wcell{ii} = - genW(restrictionCell, IRF_coef, LR_coef);
    end
 
    while flagStop == false
     
        td = td + 1;
     
        % Draw orthonormal matrix
        Q = OrthNorm(nvar);
     
        % Check restrictions
        checker = logical(zeros(nshocks, 1));
        minuschecker = logical(zeros(nshocks, 1));
        for ii = 1:nshocks
            checker(ii) = all(Wcell{ii} * Q(:, ii) <= 0); % returns 1 if all SR satisfied for shock ii
            minuschecker(ii) = all(Wcell{ii} * Q(:, ii) >= 0);
        end
        include = 0;
        if all(checker)
            include = 1;
        elseif all(minuschecker)
            include = - 1;
        end
     
        % If restrictions are satisfied, compute IRFs for the desired periods (nstep)
        if include == 1 || include == - 1
            ad = ad + 1;
            if include == 1
                IRF_in(:, :, :, ad) = irftimesorth(IRF_coef, Q);
            elseif include == - 1
                IRF_in(:, :, :, ad) = - irftimesorth(IRF_coef, Q);
            end
         
            if ad == 100 * ww
                disp(['Loop: ' num2str(ad) ' / ' num2str(td) ' draws']);
                ww = ww + 1;
            end
        else
            rd = rd + 1;
        end
     
        % Collector of indices
        for ff = 1:size(drawMatrix, 1)
            if drawMatrix(ff, 2) == 0 && td == drawMatrix(ff, 1)
                flagIndiv(ff) = true;
                collector(ff, :) = [ad, rd, td];
            elseif drawMatrix(ff, 2) == 1 && ad == drawMatrix(ff, 1)
                flagIndiv(ff) = true;
                collector(ff, :) = [ad, rd, td];
            end
        end
     
        % Stop if all stop rules satisfied
        flagStop = logical(prod(flagIndiv));
     
    end
 
    IRF_in = IRF_in(:, :, :, 1 : ad); % get rid of any unnecassary rows
 
end


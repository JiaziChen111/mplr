function [IRF_in, indexmatrix, collector] = task3(VAR_config, confidence_level)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % task3 - Section 3.3 - Highest posterior density credible set in
    % SVARs
    %
    % Inputs
    % VAR_config - object generated by SVAR_config.m
    % confidence_level
    %
    % Outputs
    % IRF_in - included IRF
    % indexmatrix - order of IRF by posterior density
    % collector - collects info about number of draws
    %    [included draws; total draws]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
    A = VAR_config.A;
    Sigma = VAR_config.Sigma;
    uhat = VAR_config.uhat;
    nlag = VAR_config.nlag;
    nhorizon = VAR_config.nhorizon;
    constant = VAR_config.constant;
    drawMatrix = VAR_config.drawMatrix;
    nvar = VAR_config.nvar;
    cholsig = VAR_config.cholsig;
    Y = VAR_config.Y;
    X = VAR_config.X;
    T = VAR_config.T;
    restrictionMatrix = VAR_config.restrictionMatrix;
 
    % Maxnumber of draws
    collector = zeros(size(drawMatrix, 1), 2);
    for jj = 1:size(drawMatrix, 1)
        % if as total
        if drawMatrix(jj, 2) == 0
            % Accepted
            collector(jj, 1) = ceil(drawMatrix(jj, 1) * confidence_level);
            % Total
            collector(jj, 2) = drawMatrix(jj, 1);
            % if as accepted
        elseif drawMatrix(jj, 2) == 1
            % Accepted
            collector(jj, 1) = drawMatrix(jj, 1);
            % Total
            collector(jj, 2) = ceil(drawMatrix(jj, 1) * (1 / confidence_level));
        end
    end
 
    maxdraws = max(collector(:, 2));
 
    % Prior parameters
    A0 = zeros(nlag * nvar + constant, nvar);
    nu0 = 0;
    N0 = zeros(nvar * nlag + constant, nvar * nlag + constant);
    S0 = zeros(nvar, nvar);
 
    % Posterior parameters
    nuT = T + nu0;
    NT = N0 + X'*X;
    AbarT = NT \ (N0 * A0 + X'*X*A);
    ST = (nu0 / nuT) * S0 + (T / nuT) * Sigma + (1 / nuT) * (A - A0)'*N0*inv(NT)*X' * X * (A - A0);
    EvecA = reshape(AbarT, nvar * (nvar * nlag + constant), 1); % Posterior mean of vec(B
 
    IRF_pdf = zeros(maxdraws, 1);
    IRF_draw = zeros(nvar, nvar, nhorizon, maxdraws);
 
    % Stopping criterion
    flagIndiv = false(size(drawMatrix, 1), 1);
    flagStop = false;
 
    % Accepted draws
    ad = 0;
    % Counter
    ww = 1;
 
    IRF_in = zeros(nvar, nvar, nhorizon, maxdraws);
    IRF_pdf = zeros(maxdraws, 1);
    for ii = 1 : maxdraws
     
        % Draw Sigma
        Sigma_draw = iwishrnd(nuT * ST, nuT);
        cholsig_draw = chol(Sigma_draw, 'lower');
     
        % Draw A
        vecA = mvnrnd(EvecA', kron(Sigma,inv(NT)))';
        A_draw = reshape(vecA, constant + nvar * nlag, nvar);
     
        % Compute PDF
        IRF_pdf(ii) = irfpdf_exact(cholsig_draw, constant, EvecA, NT, nuT, ST, vecA);
     
        % Compute IRF
        IRF_in(:, :, :, ii) = IRF_coeff(A_draw, cholsig_draw, nlag, nhorizon, constant); % coefficients
     
        if ii == 100 * ww
            disp(['Loop: ' num2str(ii) ' / ' num2str(maxdraws) ' draws']);
            ww = ww + 1;
        end
     
    end
 
    indexmatrix = zeros(maxdraws, size(collector, 1));
 
    % For each drawsize
    for kk = 1:size(collector, 1)
        % Sort results in ascending order of PDF
        [~, index_sort] = sort(IRF_pdf(1:collector(kk, 2)), 'descend');
        cutoff = collector(kk, 1);
        indexmatrix(1:cutoff, kk) = index_sort(1:cutoff);
    end
 
end

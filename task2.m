function [IRF_pointID, IRF_in, indexmatrix, collector] = task2(VAR_config, confidence_level)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % task2 - Section 3.2 - Summarizing a Wald Ellipse in point-identified
    % SVARs
    %
    % Inputs
    % VAR_config - object generated by SVAR_config.m
    % confidence_level
    %
    % Outputs
    % IRF_pointID - pointID IRF
    % IRF_in - included IRF
    % indexmatrix - order of IRF by Wald stat
    % collector - collects info about number of draws
    %    [included draws; total draws]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 
    % Unspool
    A = VAR_config.A;
    Sigma = VAR_config.Sigma;
    uhat = VAR_config.uhat;
    nlag = VAR_config.nlag;
    nhorizon = VAR_config.nhorizon;
    constant = VAR_config.constant;
    drawMatrix = VAR_config.drawMatrix;
    nvar = VAR_config.nvar;
    cholsig = VAR_config.cholsig;
    Y = VAR_config.Y;
 
    % Maxnumber of draws
    collector = zeros(size(drawMatrix, 1), 2);
    for jj = 1:size(drawMatrix, 1)
        % if as total
        if drawMatrix(jj, 2) == 0
            % Accepted
            collector(jj, 1) = ceil(drawMatrix(jj, 1) * confidence_level);
            % Total
            collector(jj, 2) = drawMatrix(jj, 1);
            % if as accepted
        elseif drawMatrix(jj, 2) == 1
            % Accepted
            collector(jj, 1) = drawMatrix(jj, 1);
            % Total
            collector(jj, 2) = ceil(drawMatrix(jj, 1) * (1 / confidence_level));
        end
    end
 
    maxdraws = max(collector(:, 2));
 
    % Compute IRF
    IRF_pointID = IRF_coeff(A, cholsig, nlag, nhorizon, constant);
    IRFcol = IRFcolumns(IRF_pointID);
 
    % Draw IRFs
    ww = 1; % for display
    IRF_in = zeros(nvar, nvar, nhorizon, maxdraws);
    for ii = 1 : maxdraws
     
        IRF_in(:, :, :, ii) = recursivebootstrap(A, uhat, Y, nlag, nhorizon, constant);
     
        if ii == 100 * ww
            disp(['Loop: ' num2str(ii) ' draws']);
            ww = ww + 1;
        end
    end
    disp('-- Done!');
    disp(' ');
 
    indexmatrix = zeros(maxdraws, size(collector, 1));
 
    % For each drawsize
    for kk = 1:size(collector, 1)
        IRFdraw_col = zeros(nvar * nhorizon, nvar, collector(kk, 2));
        IRFdraw_mean = zeros(nvar * nhorizon, nvar);
        IRFdraw_square = zeros(nvar * nhorizon, nvar * nhorizon, nvar);
     
        IRF_temp = IRF_in(:, :, :, 1:collector(kk, 2));
     
        for ii = 1:collector(kk, 2)
            % for each shock
            for jj = 1:nvar
                IRFdraw_col(:, jj, ii) = IRFcolumns(IRF_temp(:, jj, :, ii));
                IRFdraw_mean(:, jj) = IRFdraw_mean(:, jj) + IRFdraw_col(:, jj, ii);
                IRFdraw_square(:, :, jj) = IRFdraw_square(:, :, jj) + IRFdraw_col(:, jj, ii) * IRFdraw_col(:, jj, ii)';
            end
        end
     
        % Compute IRF variance and precompute inverse
        IRFcov = zeros(nvar * nhorizon, nvar * nhorizon, nvar);
        invIRFcov = zeros(nvar * nhorizon, nvar * nhorizon, nvar);
        for jj = 1 : nvar
            IRFcov(:, :, jj) = IRFdraw_square(:, :, jj) / collector(kk, 2) - IRFdraw_mean(:, jj) * IRFdraw_mean(:, jj)' / (collector(kk,2)^2);
            % Offset for zeros
            invIRFcov(jj:end, jj:end, jj) = inv(IRFcov(jj:end, jj:end, jj));
        end
     
        % Compute Wald stats
        wald = zeros(nvar, collector(kk, 2));
     
        for ii = 1 : collector(kk, 2)
            for jj = 1 : nvar
                wald(jj, ii) = (IRFdraw_col(jj:end, jj, ii) - IRFcol(jj:end, jj))' * invIRFcov(jj:end, jj:end, jj) * (IRFdraw_col(jj:end, jj, ii) - IRFcol(jj:end, jj));
            end
        end
     
        % Sort results in ascending order of Wald statistics
        [~, index_sort] = sort(wald, 2);
        cutoff = collector(kk, 1);
        indexmatrix(1:cutoff, kk) = index_sort(1:cutoff);
    end
 
end